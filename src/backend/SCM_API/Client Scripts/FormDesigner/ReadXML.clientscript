/* eslint-disable no-undef */
/* eslint-disable no-unused-vars */
/*
Description.. :	Read XML from database and create form
Author....... :	DC
Date......... : 2023-11-16
*/

var _globalCount = 0;

const controlClasses = {
    "Button": Button,
    "ButtonBar": ButtonBar,
    "ButtonBarGroup": ButtonBarGroup,
    "ButtonBarItem": ButtonBarItem,
    "CheckBox": CheckBox,
    "CheckedListBox": CheckedListBox,
    "ComboBox": ComboBox,
    "DataGrid": DataGrid,
    "DataGridTable": SL.DataGridTable,
    "DateTimePicker": DateTimePicker,
    "Frame": Frame,
    "GroupBox": GroupBox,
    "Image": Image,
    "Label": Label,
    "Line": Line,
    "LinkBar": LinkBar,
    "LinkBarItem": LinkBarItem,
    "LinkBarGroup": LinkBarGroup,
    "LinkButton": LinkButton,
    "LinkLabel": LinkLabel,
    "ListBox": ListBox,
    "ListView": ListView,
    "MonthCalendar": MonthCalendar,
    "MultiChoice": MultiChoice,
    "Panel": Panel,
    "ProgressBar": ProgressBar,
    "RadioButton": RadioButton,
    "ReportViewer": ReportViewer,
    "RichTextBox": RichTextBox,
    "Schedule": Schedule,
    "ScriptEditor": ScriptEditor,
    "SplitContainerH": SL.SplitContainerH,
    "SplitContainerV": SL.SplitContainerV,
    "SplitterPanel": SL.SplitterPanel,
    "TabControl": TabControl,
    "TabPage": TabPage,
    "TextArea": TextArea,
    "TextBox": TextBox,
    "TreeNode": TreeNode,
    "TreeView": TreeView,
    "TreeListView": TreeListView,
    "WebBrowser": WebBrowser
};

// create form with all controls from XML
async function LoadFormFromXML(sXML)
{
    var xmlDoc = new DOMParser().parseFromString(sXML, "text/xml");
    var formNode = xmlDoc.getElementsByTagName("Form")[0];

    // change id tag of form node to _Form1 to avoid name conflict
    formNode.getElementsByTagName("Id")[0].textContent = "_Form1";

    var newForm = await CreateControlFromXML(formNode);
    newForm.Left = 240;
    newForm.Top = 40;
    await LoadCboControls();
    return newForm;
}

// set properties for control
async function SetBaseProperties(xmlNode, control)
{
    // set properties
    for (let row of xmlNode.childNodes)
    {
        // skip text nodes
        if (row.nodeName === "#text")
            continue;

        let sPropertyName = row.nodeName;
        let value = row.textContent;

        if (sPropertyName === "Guid")
            continue;

        // convert function name to function
        if (sPropertyName.includes("On") && value.includes("("))
        {
            try
            {    
                value = eval(value);
            }
            catch (e) 
            {
                console.log("Error converting function name " + value + " to function");
            }
        }

        // convert numeric string to number
        if (!isNaN(value))
            value = Number(value);

        // convert boolean string to boolean
        if (value === "true")
            value = true;
        else if (value === "false")
            value = false;

        control[sPropertyName] = value;
    }
}

// create javascript control from XML
async function CreateControlFromXML(xmlNode, xmlParentNode, control)
{
    // skip text nodes
    if (xmlNode.nodeName === "#text")
        return;
    
    // read type
    var xmlType;
    var sType;
    if (xmlNode.getElementsByTagName("xtype").length > 0)
    {
        xmlType = xmlNode.getElementsByTagName("xtype")[0];
        // remove Starlims from type name
        sType = xmlType.textContent.replace("Starlims", "");
    }
    else
        sType = xmlNode.getAttribute("xsi:type").replace("Starlims", "");

    if (!sType)
        return;

    // get control id
    var sGuid = xmlNode.getElementsByTagName("Guid")[0].textContent;

    if (sType === "Form")
    {
        control = _Form1;
        control.xType = "Form";

        // set form width and height
        control.Width = Number(xmlNode.getElementsByTagName("Width")[0].textContent);
        control.Height = Number(xmlNode.getElementsByTagName("Height")[0].textContent);
    }
    else
    {
        if (sType !== "SplitterPanel")
        {
            // create new control
            const controlClass = controlClasses[sType];
            if (controlClass)
                control = new controlClass();
            else
            {
                await Dialogs.MessageBox("Control " + sType + " not supported", "Error", "ERROR", "OKONLY");
                return;
            }
        }
        control.xType = sType;
        control.guid = sGuid;
    }

    // set properties
    for (let node of xmlNode.childNodes)
    {
        // skip text nodes
        if (node.nodeName === "#text")
            continue;

        let sPropertyName = node.nodeName;
        let value = node.textContent;

        if (sPropertyName === "Guid")
            continue;

        // skip form title
        if (control.xType === "Form" && sPropertyName === "Text")
        {
            control.title = "";
            continue;
        }

        if (sPropertyName === "(Id)")
            sPropertyName = "Id";

        // convert function name to function
        if (sPropertyName.includes("On") && value.includes("("))
        {
            try
            {    
                value = eval(value);
            }
            catch (e) 
            {
                console.log("Error converting function name " + value + " to function");
            }
        }

        // convert numeric string to number
        if (!isNaN(value))
            value = Number(value);

        // convert boolean string to boolean
        if (value === "true")
            value = true;
        else if (value === "false")
            value = false;

        // convert XML RootTable property to StarlimsDataGridTable object
        if (sPropertyName === "RootTable")
        {
            // only one table supported by now
            let table = new StarlimsDataGridTable();
            table.xType = "StarlimsDataGridTable";
            value = new DOMParser().parseFromString(node.outerHTML, "text/xml");
            table.Id = GetProperty(value, "Id");
            table.Guid = GetProperty(value, "Guid");
            table.DataMember = GetProperty(value, "DataMember", true);
            table.Caption = GetProperty(value, "Caption", true);
            table.RowHeight = Number(GetProperty(value, "RowHeight"));
            table.TotalRow = GetProperty(value, "TotalRow") === "true";
            table.GroupTotalRow = GetProperty(value, "GroupTotalRow") === "true";
            table.TranslateAttrColumn = GetProperty(value, "TranslateAttrColumn") === "true";

            // load table properties
            await LoadDataProperties(table);

            // TODO: fix this
            // add to outline tree
            //let parentNode = await FindNodeById(control.Id);
            //AddControlToOutline(table, parentNode);

            // load columns by parsing xml data
            for (let column of value.getElementsByTagName("__array__Columns")[0].childNodes)
            {
                // skip text nodes
                if (column.nodeName === "#text")
                    continue;

                let gridColumn = new StarlimsDataGridColumn();
                gridColumn.xType = "StarlimsDataGridColumn";
                await LoadDataProperties(gridColumn);

                gridColumn.Guid = GetProperty(column, "Guid");
                gridColumn.Id = GetProperty(column, "Id");
                gridColumn.Caption = GetProperty(column, "Caption") ? GetProperty(column, "Caption") : GetProperty(column, "Id");
                gridColumn.Width = Number(GetProperty(column, "Width"));
                gridColumn.ReadOnly = GetProperty(column, "ReadOnly") === "true";
                gridColumn.Visible = GetProperty(column, "Visible") === "true";
                gridColumn.DataMember = GetProperty(column, "DataMember");
                gridColumn.Type = GetProperty(column, "Type");
                gridColumn.TranslateDisplayColumn = GetProperty(column, "TranslateDisplayColumn") === "true";
                gridColumn.CheckBoxTrueValue = GetProperty(column, "CheckBoxTrueValue");
                gridColumn.CheckBoxFalseValue = GetProperty(column, "CheckBoxFalseValue");
                gridColumn.CheckBoxNullValue = GetProperty(column, "CheckBoxNullValue");
                gridColumn.TranslateDataColumn = GetProperty(column, "TranslateDataColumn") === "true";
                gridColumn.TranslateAttrColumn = GetProperty(column, "TranslateAttrColumn") === "true";
                gridColumn.GroupBy = GetProperty(column, "GroupBy") === "true";
                gridColumn.CardCaption = GetProperty(column, "CardCaption") === "true";
                gridColumn.CardIcon = GetProperty(column, "CardIcon") === "true";
                gridColumn.AllowSize = GetProperty(column, "AllowSize") === "true";
                gridColumn.AllowSort = GetProperty(column, "AllowSort") === "true";
                gridColumn.AllowDrag = GetProperty(column, "AllowDrag") === "true";
                gridColumn.CheckBoxTriState = GetProperty(column, "CheckBoxTriState") === "true";
                gridColumn.WordWrap = GetProperty(column, "WordWrap") === "true";
                gridColumn.MaxLines = Number(GetProperty(column, "MaxLines"));
                gridColumn.TrimSpaces = GetProperty(column, "TrimSpaces") === "true";
                gridColumn.FormatStringsToLocal = GetProperty(column, "FormatStringsToLocal") === "true";
                table.Columns.Add(gridColumn);
            }

            control.RootTable = table;
            continue;
        }

        control[sPropertyName] = value;
    }

    if(!control.Id)
    {
        // set control id by type and global count
        control.Id = control.xType + "_" + ++_globalCount;
    }

    xmlNode.Id = control.Id;

    if (sType !== "Form")
    {
        // add control to hash table
        LoadDataProperties(control);

        htControls.Add(control.Id, control);

        // add control to outline treePanel
        let parentNode = await GetNodeFromXML(xmlParentNode);
        await AddControlToOutline(control, parentNode);

        ApplyContextMenu(control);
    }

    // handle Panel1 and Panel2 properties for StarlimsSplitContainer
    if (sType === "SplitContainerH" || sType === "SplitContainerV")
    {
        let childNode = xmlNode.getElementsByTagName("Panel1")[0];
        if (childNode)
            control.Panel1 = await CreateControlFromXML(childNode, xmlNode, control.Panel1);

        childNode = xmlNode.getElementsByTagName("Panel2")[0];
        if (childNode)
            control.Panel2 = await CreateControlFromXML(childNode, xmlNode, control.Panel2);

        if(sType === "SplitContainerH")
            control.SplitterDistance = control.Panel1.Height;
        else
            control.SplitterDistance = control.Panel1.Width;

        // Modify splitter distance when splitter is dragged
        var splitter = control.child('splitter');

        splitter.on('dragend', function() {
            if (sType === "SplitContainerH")
                control.SplitterDistance = control.Panel1.Height;
            else
                control.SplitterDistance = control.Panel1.Width;
        });
    }

    if (sType === "SplitterPanel")
        SetZIndex();

    if (sType === "TabControl")
    {
        var nSelectedPage = control.SelectedPage;
    }

    // get all child controls (only current level)
    let allControls = Array.from(xmlNode.getElementsByTagName("__array__Controls"));
    let aControls = allControls.filter(item => item.parentNode === xmlNode && item.nodeName !== "#text");

    if (aControls && aControls.length > 0)
    {
        for (let child of aControls[0].childNodes)
        {
            if (child.nodeName === "#text")
                continue;

            let childControl = await CreateControlFromXML(child, xmlNode);

            if (childControl && control.Controls && childControl.xType !== "TabPage")
                control.Controls.Add(childControl);
        }
        return control;
    }

    // get all groups (only current level)
    let allGroups = Array.from(xmlNode.getElementsByTagName("__array__Groups"));
    let aGroups = allGroups.filter(item => item.parentNode === xmlNode && item.nodeName !== "#text");

    if (aGroups && aGroups.length > 0)
    {
        for (let group of aGroups[0].childNodes)
        {
            if (group.nodeName === "#text")
                continue;

            let childControl = await CreateControlFromXML(group, xmlNode);

            // add groups for linkbar
            if (childControl && control.Groups)
                control.Groups.Add(childControl);
        }
        return control;
    }

    // get all items (only current level)
    let allItems = Array.from(xmlNode.getElementsByTagName("__array__Items"));
    let aItems = allItems.filter(item => item.parentNode === xmlNode && item.nodeName !== "#text");

    if (aItems && aItems.length > 0)
    {
        for (let item of aItems[0].childNodes)
        {
            if (item.nodeName === "#text")
                continue;

            let childControl = await CreateControlFromXML(item, xmlNode);

            // add tab pages for tabcontrol
            if (childControl && control.TabPages)
                control.TabPages.Add(childControl);

            // add items for linkbar group
            if (childControl && control.Items)
                control.Items.Add(childControl);
        }
        
        // set selected page for tabcontrol
        if(control.TabPages && control.TabPages.Count > 0)
            control.SelectedPage = nSelectedPage;
    }
    
    return control;
}

// get treePanel node from xml node 
async function GetNodeFromXML(xmlNode, xmlParentNode)
{
    if (xmlNode)
    {
        let parentNode = xmlParentNode ? await FindNodeById(xmlParentNode.Id) : null;
        return await FindNodeById(xmlNode.Id, parentNode);
    }
    else
        return _treePanel.getRootNode().firstChild;
}

// get property value from xml node
function GetProperty(column, name, bReturnEmptyString = false)
{
    let element = column.getElementsByTagName(name);
    if (element.length > 0 && element[0].textContent)
        return element[0].textContent;
    else
    {
        return bReturnEmptyString ? "" : null;
    }
}

// load control properties
async function LoadDataProperties(control)
{
    
    let xmlProperties = await lims.GetData("FormDesigner.dsControlProperties", [control.xType]);
    if (!xmlProperties)
    {
        await Dialogs.MessageBox("Error loading properties for control " + control.xType, "Error", "ERROR", "OKONLY");
        return;
    }

    _dgdProperties.Data = xmlProperties;
    control.DataPropertiesXml = xmlProperties;
    control.DataProperties = _dgdProperties.DataSet.Tables[0].Select("PROPERTY_VALUE is not null");
}